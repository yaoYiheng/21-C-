/*
Demonstrates automatic and static local variables.
 */
#include <stdio.h>
void func1(void);
int main(int argc, char const *argv[])
{
	int count;

	for(count = 0; count < 5; count++){
		func1();
	}

	return 0;
}
void func1(void){
	static int x = 0;
	int y = 0;

	printf("x = %d, y = %d\n",x++, y++ );
}
/*输出结果如下:
x = 0, y = 0
x = 1, y = 0
x = 2, y = 0
x = 3, y = 0
x = 4, y = 0

	每次迭代后, 静态变量的值都会增加1, 因为在两次调用函数之间, 该变量的值保持不变;
	而每次调用函数时, 动态变量y都被初始化为0, 因此其值没有增加.
	程序还表明, 定义变量是对它进行初始化的方式也不同.静态变量只在函数首次被调用时
	初始化一次, 以后调用时, 程序知道该变量已被初始化, 因此不会再次初始化, 而变量
	仍为前一次退出函数时的值. 而对于动态变量, 每次函数被调用时, 都会被初始化为指定
	的值
 */

/*
	若将第17 18行改为:
	static int x ;
	int y ;
	可能发现每次迭代后, y的值都增加1. 这意味着在两次调用函数之间, y的值保留不变
	虽然它是一个动态局部变量. 上面有关动态变量的讨论是错误的吗?
	不是. 这只是一种巧合.原因如下: 每次函数被调用时, 都创建一个新的y, 但在两次
	调用时, 编译器用来存储y的内存单元是相同的.如果函数没有对y进行初始化, 则该内
	存单元仍保留y在前一次调用期间的值, 巧合而已, 并非总会出现这样的情况.


 */

